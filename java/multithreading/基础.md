# 多线程基础

## 并发编程可以总结为三个核心问题：分工、同步、互斥

* 分工：指的是如何高效地拆解任务并分配给线程
* 同步：指的是线程之间如何协作
* 互斥：是保证同一时刻只允许一个线程访问共享资源

## Happens-Before 规则

**前面一个操作的结果对后续操作是可见的**

* 程序的顺序性规则 

  这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。

* volatile 变量规则

  这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。

* 管程中锁的规则

  这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

* 线程 start() 规则

  这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

* 线程 join() 规则

  这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。

## volatile 关键字

**禁用缓存以及编译优化**

## synchronized 关键字

* 当synchronized修饰方法时，被锁定的是什么

  > * 当修饰静态方法的时候，锁定的是当前类的 Class 对象。
  > * 当修饰非静态方法的时候，锁定的是当前实例对象 this。

## 用锁的最佳实践

* 永远只在更新对象的成员变量时加锁
* 永远只在访问可变的成员变量时加锁
* 永远不在调用其他对象的方法时加锁